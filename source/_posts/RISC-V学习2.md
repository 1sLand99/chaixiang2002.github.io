---
title: RISC-V学习2
comments: true
date: 2023-08-07 19:22:24
layout:
updated:
categories:
tags:
lang:
---
# 坑

# 疑问

##### 1. OS 02 内存管理，这里什么意思？？？

![1691503779243](image/RISC-V学习2/1691503779243.png)

2. 为什么 栈指针sp要加上(hart id * 2^10),而且haerid，不就是0吗？这样的意义是什么？

   ![1691504143678](image/RISC-V学习2/1691504143678.png)







# 第5章 汇编和C的相互调用

![1691336056967](image/RISC-V系统学习/1691336056967.png)

- volatile: 不优化的关键字
- asm：汇编关键字

![1691409029388](image/RISC-V学习2/1691409029388.png)

r相当于C语言里建议编译器的register关键字

![1691409247792](image/RISC-V学习2/1691409247792.png)

# 第6章  RVOS 介绍

![1691409364850](image/RISC-V学习2/1691409364850.png)

![1691409463215](image/RISC-V学习2/1691409463215.png)

- Machine模式		访问物理地址
- User模式			物理内存保护
- Supervisor模式	支持虚拟地址

![1691409642475](image/RISC-V学习2/1691409642475.png)

![1691409832530](image/RISC-V学习2/1691409832530.png)

![1691409844010](image/RISC-V学习2/1691409844010.png)

- 内存分配
- 多线程
- 任务互斥
- 软件定时器

![1691409937392](image/RISC-V学习2/1691409937392.png)

# 第7章 hello RCVS

![1691410442177](image/RISC-V学习2/1691410442177.png)

- 通过访问这些地址来访问这些元器件

![1691410625647](image/RISC-V学习2/1691410625647.png)

ROM掉电，数据还在

![1691410753276](image/RISC-V学习2/1691410753276.png)

- 0x8000是一个特殊的地址，内存的第一个指令必须在这

![1691410900425](image/RISC-V学习2/1691410900425.png)

![1691411301424](image/RISC-V学习2/1691411301424.png)

##### CSRs：

- 每一个模式都有一组自己的寄存器，这些寄存器叫 **CSR寄存器**

![1691411431130](image/RISC-V学习2/1691411431130.png)

- 一上电就是machine模式

![1691411686682](image/RISC-V学习2/1691411686682.png)

##### CSR指令：专门对这些寄存器的指令

![1691411717067](image/RISC-V学习2/1691411717067.png)

CSRRW

- 该指令 是原子指令
- 两步操作，对值”零扩展“ （也就是不足补零）

![1691411987837](image/RISC-V学习2/1691411987837.png)

CSRW

![1691412073134](image/RISC-V学习2/1691412073134.png)

- 该指令：读CSR值，写入RD，再对CSR根据RS1 set Bit。
- set Bit:意思是，当RS1中某位为1，则CSR此位也写成1，其他位不变

![1691412178348](image/RISC-V学习2/1691412178348.png)

csrr： 仅进行读操作

![1691412458590](image/RISC-V学习2/1691412458590.png)

![1691412629474](image/RISC-V学习2/1691412629474.png)

- wfi：休眠指令，如果仅用j 这个死循环会非常耗电

![1691412805659](image/RISC-V学习2/1691412805659.png)

大写的.S文件支持预处理指令

![1691413157371](image/RISC-V学习2/1691413157371.png)

![1691414228378](image/RISC-V学习2/1691414228378.png)

##### UART硬件连接

![1691414430487](image/RISC-V学习2/1691414430487.png)

##### UART特点

![1691414783618](image/RISC-V学习2/1691414783618.png)

##### UART通信协议

1. 空闲位：当总线空闲时，这根线处于 高电平 '1'
2. 起始位：发送1个bit时间的 低电平'0'信号，表示开始传送字符
3. 数据位：起始位后，就是传输的数据，数据长度可以是5/6/7/8/9位，构成一个字符，一般8位，先放送最低位，最后发最高位
4. 校验位：串口校验分：
   - 无校验
   - 奇校验
   - 偶校验
   - mark parity：校验位始终为1
   - space parity：校验位始终为0
5. 停止位：结束时，可以是1位高电平、2位、1.5位

![1691414835757](image/RISC-V学习2/1691414835757.png)

![1691415662451](image/RISC-V学习2/1691415662451.png)

8个寄存器，UART0地址+reg偏移量，访问这8个寄存器

- 每个寄存器都有2个模式，读模式，写模式

![1691415958015](image/RISC-V学习2/1691415958015.png)

![1691415682930](image/RISC-V学习2/1691415682930.png)

##### NS16550a的初始化

- 设置波特率

![1691416655204](image/RISC-V学习2/1691416655204.png)

外围设备要配波特率，

![1691416840251](image/RISC-V学习2/1691416840251.png)

x是18432，我们要配这个a，使得y的结果合理

- 所以的板子频率都是18432MHZ或者73728MHZ
- 所以可移配的值都是16位，而Uart寄存器是8位，所以需要两个寄存器

![1691417021952](image/RISC-V学习2/1691417021952.png)

为什么需要写LCR寄存器，因为DLL、DLM和读和写寄存器 复用了地址，

要么使人中断的效果，要不使用设置波特率的效果，功能只能2选1.

我们通过拨动一个开关来选择我们要的效果（设置LCR寄存器的第7位）

![1691421501336](image/RISC-V学习2/1691421501336.png)

设置奇偶校验位

![1691422003518](image/RISC-V学习2/1691422003518.png)

![1691417171658](image/RISC-V学习2/1691417171658.png)

##### Uart寄存器，是8位的！！

##### Ns16550a 的读写

- 轮询：不断查看发送寄存器是否空闲，空闲就把数据放入该寄存器，当寄存器有值就会发出去
- 中断：当寄存器空闲了，串口设备就会提醒我们把东西放进去

![1691417691616](image/RISC-V学习2/1691417691616.png)

THR寄存器：发送寄存器，把东西放进去，他就会放进去

LSR寄存器：我们可以通过访问他特殊的位，得到发送寄存器是否空闲

![1691418085315](image/RISC-V学习2/1691418085315.png)

##### 轮询方式的实现

- 不断的读LSR寄存器的值 ，同时 与操作不断这个寄存器第5位是否为1，不满足条件说明 发送寄存器不空闲
- 如果满足条件，就把一个字符写入

![1691418353626](image/RISC-V学习2/1691418353626.png)

### !!!巨重要[第7章（下）-Hello RVOS_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Q5411w7z5/?p=17&spm_id_from=pageDriver&vd_source=f30dd07ede5a1255c0b1aaf0d2788938)

# 第8章 内存管理

![1691422189372](image/RISC-V学习2/1691422189372.png)

![1691422327133](image/RISC-V学习2/1691422327133.png)

![1691422572189](image/RISC-V学习2/1691422572189.png)

![1691422707994](image/RISC-V学习2/1691422707994.png)

![1691422911767](image/RISC-V学习2/1691422911767.png)

![1691422894259](image/RISC-V学习2/1691422894259.png)

![1691479716784](image/RISC-V学习2/1691479716784.png)

### Linked Script链接脚本语法

##### Entry命令：设置入口命令

![1691480821157](image/RISC-V学习2/1691480821157.png)

设置模块和api

![1691481077940](image/RISC-V学习2/1691481077940.png)

##### Memory命令

申请内存命令

1. 先申请一块rom内存（只读），这块内存起始地址 0，长度 256k
2. 再申请一块ram内存（可读写），起始地址0x40000000，长度4M

如果链接器发现哪些节没有设置放在哪块地址，会根据读写属性去默认放入

![1691481221180](image/RISC-V学习2/1691481221180.png)

##### Section命令：

描述输入文件 如何映射到 目标文件，以及 目标setion 如何放入内存

`.=0x10000 // .是当前指针位置，这里把当前指针位置设置为0x10000`

`.text:{*(.text)}    // output section : input section,这里是在0x10000 所有输入文件的.text放入目标文件的.text `

![1691482314698](image/RISC-V学习2/1691482314698.png)

Provide命令

赋值命令，把后面的值赋给前面

![1691482914315](image/RISC-V学习2/1691482914315.png)

![1691483737686](image/RISC-V学习2/1691483737686.png)

![1691483749721](image/RISC-V学习2/1691483749721.png)

![1691483865596](image/RISC-V学习2/1691483865596.png)

这里定义了一些全局变量，word代表32为空间

![1691483964579](image/RISC-V学习2/1691483964579.png)

> .ld -> .S -> .c

![1691484047061](image/RISC-V学习2/1691484047061.png)

![1691484198391](image/RISC-V学习2/1691484198391.png)

![1691484312064](image/RISC-V学习2/1691484312064.png)

![1691484425368](image/RISC-V学习2/1691484425368.png)

![1691484490021](image/RISC-V学习2/1691484490021.png)

4k对齐

![1691484605177](image/RISC-V学习2/1691484605177.png)

##### 定义Page的数据结构

page_token:用第一位表示自己是否被用掉

page_last:当好几个page被化成一块给用户时，用第二位表示自己是不是该块的 最后一个

![1691485032733](image/RISC-V学习2/1691485032733.png)

##### Page的分配

![1691485464554](image/RISC-V学习2/1691485464554.png)

##### Page的释放

![1691485445134](image/RISC-V学习2/1691485445134.png)

##### 物理内存保护和虚拟内存

![1691485634126](image/RISC-V学习2/1691485634126.png)

##### 练习

![1691485736305](image/RISC-V学习2/1691485736305.png)


# 第九章 上下文切换和协作多任务

![1691504468820](image/RISC-V学习2/1691504468820.png)


![1691504593072](image/RISC-V学习2/1691504593072.png)


- 多任务：在单核上跑多个执行流，需要上下文切换
- 上下文切换：当一个hart要执行时，先把上一个hert在寄存器上所有的值存入栈中，这个hert再工作，再切回来时，再保存自己，恢复另一个hert的上下文

![1691504722190](image/RISC-V学习2/1691504722190.png)


![1691505114479](image/RISC-V学习2/1691505114479.png)


![1691505356317](image/RISC-V学习2/1691505356317.png)


1. 协作式多任务：任务 工作一段时间后，主动把cpu让出来，缺点：程序员忘记写让了
2. 抢占式多任务

![1691505375750](image/RISC-V学习2/1691505375750.png)


- ra：返回值地址寄存器， 但是在这里存放 该任务的当前执行命令的地址，如i
- mscratch寄存器：是一个 mechine模式的寄存器，一会指向a的上下文，一会指向b的上下文

![1691505935032](image/RISC-V学习2/1691505935032.png)


![1691506328530](image/RISC-V学习2/1691506328530.png)


- t6是最后一个被覆盖的通用寄存器

![1691506716280](image/RISC-V学习2/1691506716280.png)


1. 定义上下文的结构体
2. 定义一个任务，定义他的 栈和上下文
3. 初始化一个任务：
   - ？
   - 初始化该任务的栈
   - 把任务的第一条指令的地址放入 上下文的ra中

![1691506952949](image/RISC-V学习2/1691506952949.png)


把任务task0的上下文给schedule函数，switch_to就跳到了第一个任务

![1691507264016](image/RISC-V学习2/1691507264016.png)

1. 内核->初始化sched->schedule任务->我们的任务

![1691507439872](image/RISC-V学习2/1691507439872.png)


1. 直接定义1个任务栈数组 和 1个上下文数组
2. top表示有多少个任务，cur表示当前任务的下标
3. 通过 轮转 的方式实现上下文切换
4. task_yield 主动放弃任务

![1691507847482](image/RISC-V学习2/1691507847482.png)


![1691508103582](image/RISC-V学习2/1691508103582.png)


![1691508150288](image/RISC-V学习2/1691508150288.png)


![1691508233633](image/RISC-V学习2/1691508233633.png)












































a
