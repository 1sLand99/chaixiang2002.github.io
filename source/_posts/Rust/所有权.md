[所有权 - Rust语言圣经(Rust Course)](https://course.rs/basic/ownership/ownership.html)
默认不变量和常量有区别
const 的常量，编译期固定，不可在改变，不可mut

可变量：let mut a=1,可以改变

默认不变量：let a=1，不可在改变值，但可以转化成可变量



动态字符串类型: `String`

字符串字面值 `let s ="hello"`，`s` 是被硬编码进程序里的字符串值（类型为 `&str` ）



## [变量绑定背后的数据交互](https://course.rs/basic/ownership/ownership.html#%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92)

#### 堆与栈

#### 基本类型和复杂类型

##### 绑定

```rust
let a=1;
let b=a;
```

##### 函数传值

```
let x=1
fun(x)
```

对于基本类型，他们默认是拷贝，所以上面2个例子，后面a和x的可以正常使用，**值内存分配在栈上**
对于复杂类型，如String，默认是移动，所有权转移到其他变量或者函数。如果上面2个例子是复杂类型，a和x无法在使用了。**值内存分配在堆上**

对于所有复杂类型，都不会默认拷贝，必须手动clone（）。



在 Rust 中，并不是所有的变量复制都是在堆上进行的。变量复制是否涉及堆，取决于变量的数据类型和具体的操作。

### 1. 基本类型的复制（栈上）

- **基本类型**（如整数 `i32`、浮点数 `f64`、布尔值 `bool`、字符 `char`、固定大小的数组 `[T; N]` 等）存储在栈上，并且当它们被复制或传递时，实际的复制行为发生在栈上。Rust 会直接复制这些数据，而不涉及堆内存的分配。

  例如：

  ```rust
  let x = 42;
  let y = x; // 这里 x 的值被复制到 y，复制发生在栈上
  ```

  在这个例子中，`x` 和 `y` 都是栈上的变量，它们存储的是值的副本。

### 2. 复杂类型的复制（涉及堆和栈）

- **复杂类型**（如 `String`、`Vec<T>`、`Box<T>` 等）通常涉及堆内存的分配。它们在栈上存储一个指向堆内存的指针（以及长度、容量等元数据），而实际的数据存储在堆上。

  当这些类型被复制时，默认情况下会发生**移动**，即栈上的指针被复制，堆上的数据不会被复制，原来的变量会失效。如果你想要真正复制堆上的数据，需要使用 `clone()` 方法，这时会在堆上进行数据的复制。

  例如：

  ```rust
  let s1 = String::from("hello");
  let s2 = s1.clone(); // 深拷贝，复制堆上的数据
  ```

  在这个例子中，`s1.clone()` 会在堆上创建 `s1` 数据的副本，并将其指针分配给 `s2`。这意味着 `s2` 和 `s1` 拥有独立的堆内存，而它们各自的指针则存储在栈上。

### 3. 拷贝与移动的区别

- **拷贝**（Copy trait）：对于实现了 `Copy` trait 的类型（如基本类型），复制操作非常轻量，通常发生在栈上。
- **移动**（Move）：对于不实现 `Copy` trait 的类型（如 `String`），默认的赋值操作会移动数据，这只会移动栈上的指针和元数据，而不是复制堆上的内容。

### 总结

- **基本类型**的复制在栈上完成。
- **复杂类型**的复制默认是移动，只涉及栈上的指针。如果要复制堆上的实际数据，需要使用 `clone()` 方法，这时复制操作会涉及堆内存。
