| 需求单/缺陷jira链接 | **链接到相关 JIRA epic 或功能**                                                                     |
| ------------------- | --------------------------------------------------------------------------------------------------------- |
| 文档状态            | **草稿**                                                                                            |
| 开发负责人          | ![](http://wiki.ntimespace.com/plugins/servlet/confluence/placeholder/template-variable?name=documentOwner) |
| 所属部门            | ``                                                                                                 |
| 涉及模块            | ``                                                                                                 |

![](http://wiki.ntimespace.com/plugins/servlet/confluence/placeholder/macro?definition=e3RvY30&locale=zh_CN&version=2)

# 1 需求变更记录

| 日期      | 内容      | 修改人    | 是否已与关联研发/测试确认 |
| --------- | --------- | --------- | ------------------------- |
| `` | `` | `` | ``                 |

# 2 方案所属端

*这里只写本方案的修改端，如Android需求只勾选Android，涉及接口协议由服务端开发者在服务端方案设计中编写*

| **IaaS**         | **PaaS**   | IaaS                                                                    |
| ---------------------- | ---------------- | ----------------------------------------------------------------------- |
| * 基础服务* 固件* 镜像 | * 管理平台* 接口 | ***Android*** **PC-h5*** **h5官网*** **h5页面** |

# 3 名词或术语解释

| 缩写      | 全称/中文名 | 描述      |
| --------- | ----------- | --------- |
| `` | ``   | `` |

# 3 待确认/沟通问题

## 3.1 前置条件

* **在此输入任务，用"@+人名"将任务分派并用"//"选择到期日**
* **在此输入任务，用"@+人名"将任务分派并用"//"选择到期日**

## 3.2 待确认/沟通问题

* **在此输入任务，用"@+人名"将任务分派并用"//"选择到期日**
* **在此输入任务，用"@+人名"将任务分派并用"//"选择到期日**

# 4 需求背景

    *为什么要做，理由和原因是什么*

## 4.1 业务背景

**       业务名称： 业务现状：什么问题 业务描述：要做啥 **

## 4.2 技术背景

    技术沉淀。 现有架构描述 现有系统容量

# 5 需求分析

## 5.1业务痛点

* 描述系统当前问题*

## 5.2 业务需求

* 改造的内容 新增的功能等*

## 5.3 性能需求

* 预估系统平均容量 预估系统峰值容量 响应时间 并发用户数 系统稳定性*

# 6 总体设计

## 6.1 系统架构图

*梳理业务系统边界，明确系统的上下游关系。*

*梳理技术栈、关键组件*

## 6.2 系统功能模块

*设计系统有哪些模块，模块间关系。*

## 6.3 数据模型

## 6.4 业务流程

*描述在系统层面发生的数据流、事件流*

# 7 详细设计

## 7.1 接口设计

*输入/处理/输出*

## 7.3 基于纯拓展工具的实现设计

### 7.3.1 功能实现说明

![](http://wiki.ntimespace.com/download/attachments/31595797/image2024-10-16_15-10-3.png?version=1&modificationDate=1729062603857&api=v2 "云手机项目 &gt; 守护应用程序进程功能方案 &gt; image2024-10-16_15-10-3.png")

*拓展工具应用新增一个AppDaemonActivity，一个AppGuardService。*

* *AppDaemonActivity是一个活动页面，负责给用户勾选想要保活的应用，List`<String>` appDaemonList会存储每个第三方应用的勾选状态，通过SharedPreferences对进行持久化存储，保证重启前后状态一致，通过Preference按钮更新要守护的应用列表 *
* *AppGuardService是一个服务，通过Handler来不停进行的对应用的保活，appDaemonList是从AppDaemonActivity获取的要守护的应用列表。 *

*具体保活逻辑： *

1. *拓展工具启动时，创建AppGuardService*
2. *AppGuardService通过activityManager.getRunningAppProcesses()获取正在运行的程序*
3. *AppGuardService的守护的应用列表是和AppDaemonActivity同步的，持久化是SharedPreferences做的 *
4. *发现守护的应用列表不在运行，就拉起来那个应用*

### 设计说明：

1. **AppDaemonActivity** ：

* 该 Activity 提供一个用户界面，用户可以勾选他们想要进行保活的应用程序。
* `List<String> appDaemonList` 用于存储用户选择的应用列表。
* 通过 `SharedPreferences` 对应用的选择状态进行持久化，确保应用重启后用户的选择仍然存在。
* 用户可以通过界面上的按钮更新守护的应用列表。

1. **AppGuardService** ：

* 该 Service 通过 `Handler` 不断检查守护的应用是否在运行。
* 使用 `activityManager.getRunningAppProcesses()` 来获取当前正在运行的进程。
* 如果发现某个守护应用未运行，则重新启动该应用。
* 保活的应用列表与 `AppDaemonActivity` 保持同步，并通过 `SharedPreferences` 进行持久化存储。

### 实现步骤：

1. **AppDaemonActivity 逻辑：**
   * 加载并显示用户已勾选的应用列表。
   * 使用 `SharedPreferences` 持久化保存应用列表。
   * 提供按钮更新 `appDaemonList`，并通知 `AppGuardService` 更新守护列表。
2. **AppGuardService 逻辑：**
   * 当服务启动时，通过 `SharedPreferences` 获取 `appDaemonList`。
   * 使用 `Handler` 定时检查守护的应用是否正在运行。
   * 如果发现某个守护的应用没有运行，则启动该应用。

## 7.4基于**拓展工具**功能的页面交互+framework的Persistent应用属性的设计

### 7.4.1 功能实现说明

![应用启动流程图](https://supabase.mermaidchart.com/storage/v1/object/public/chatgpt-diagrams/2024-10-16/d441f216-4f27-44c8-b516-7538e47099cf.png)

![](http://wiki.ntimespace.com/download/attachments/31595797/image2024-10-16_16-4-27.png?version=1&modificationDate=1729065867444&api=v2 "云手机项目 &gt; 守护应用程序进程功能方案 &gt; image2024-10-16_16-4-27.png")

* **startPersistentApps** 方法会调用以获取系统中的持久化应用。
* 进行  **内存优化检查** ，如果开启了内存优化模式且不满足特定条件（如 `vendor.cts_gts.status`），则跳过某些应用的启动。
* 从配置文件中读取需要守护的第三方应用，并将这些应用加入待处理的应用列表。
* **addAppLocked** 方法会被调用来处理这些应用，允许通过自定义逻辑处理第三方应用。
* 如果应用有 **PERSISTENT_MASK** 标记，会进行检查，跳过普通的持久化应用处理。
* 对于自定义应用，跳过持久化标记检查。
* 系统会通过 **ProcessList** 来启动这些应用进程。
* 使用 **Zygote/AppZygote** 启动进程，完成应用的启动和守护。

### 实现步骤：

1. ***拓展工具应用视图*AppDaemonActivity 逻辑：**
   * 加载并显示用户已勾选的应用列表。
   * 使用 `SharedPreferences` 持久化保存应用列表。
   * 提供按钮更新 `appDaemonList`，并写入到指定文件中。
2. framework层**PersistentApp保活处理**
   * 从配置文件中读取需要守护的第三方应用，并将这些应用加入待处理的应用列表
   * **addAppLocked** 方法会被调用来处理这些应用，允许通过自定义逻辑处理第三方应用
   * 对于自定义应用，跳过持久化标记检查
   * 使用 **Zygote/AppZygote** 启动进程，完成应用的启动和守护

## 7.5两种方法的优缺点

### 方法1：通过系统应用实现保活

 **优点** ：

1. **灵活性高** ：保活逻辑独立于AOSP框架，修改和测试相对独立，不影响系统的稳定性。只需要在现有的系统应用中增加界面和逻辑。
2. **安全性和可控性** ：因为是一个独立的系统应用，只要正确配置权限，不会轻易影响系统的其他部分，减少对整个系统的不确定影响。
3. **开发难度较低** ：仅需增加一个新的Activity和Service，依赖已有的系统API，开发周期短且容易实现。
4. **适用性广** ：不修改系统的核心逻辑，升级或迁移到新的Android版本时更容易维护。
5. **独立更新** ：通过系统应用进行管理，后续可以独立发布或更新，不需要修改AOSP框架源码。

 **缺点** ：

1. **性能消耗** ：需要后台运行一个Service来持续检测应用是否被杀掉，可能在长时间运行中有一些性能开销。
2. **保活效果有限** ：由于Android系统的进程管理机制，特别是在高内存压力或省电模式下，系统可能依旧会杀掉这个后台Service，导致无法实现真正意义上的“保活”。
3. **依赖系统API** ：当系统API变更时，需要及时调整应用逻辑。

---

### 方法2：修改AOSP framework实现保活

 **优点** ：

1. **系统级别的保活** ：通过直接修改framework层实现的保活，保活效果更强。应用进程可以更加深入地嵌入到系统的进程管理中，防止系统过度杀掉目标进程。
2. **无额外性能开销** ：不需要创建单独的Service去持续检测，节省资源，因为应用的管理交由系统本身完成。
3. **对系统透明** ：应用的保活逻辑被集成在系统的进程管理中，属于系统自带的保活机制，减少外部依赖。

 **缺点** ：

1. **开发复杂度高** ：需要对AOSP框架有深入了解，特别是进程管理、Zygote启动等底层机制的改动，增加了开发和测试的难度。
2. **维护难度高** ：任何对framework层的修改都需要仔细考虑，可能引入不可预测的系统问题，后续系统升级、修复Bug时难度会更高。
3. **安全性和稳定性风险** ：修改系统核心组件如 `startPersistentApps()` 和 `addAppLocked()` 可能导致系统行为异常，或者影响系统的性能和安全性。

---

### 推荐选择

综合考虑后，我建议选择 **方法1** （通过系统应用实现保活）。原因如下：

1. **灵活性和低风险** ：通过独立的系统应用实现保活，开发和维护难度较低，对系统影响较小。即使出现问题也可以单独修复，不影响系统其他部分。
2. **系统兼容性** ：此方法不涉及修改系统框架，未来Android版本升级时，调整和迁移的难度较小。
3. **简单快速实现** ：对于保活的需求，系统应用Service的方案开发周期较短，且容易测试和部署。

除非对保活效果有非常高的需求，且能够接受较高的开发复杂度和风险，否则更推荐通过系统应用来实现保活。

# 8 实施计划和分工

| 序号      | 任务      | 人员      | 计划工时  | 开始时间  | 结束时间  | 里程碑    | 备注      |
| --------- | --------- | --------- | --------- | --------- | --------- | --------- | --------- |
| `` | `` | `` | `` | `` | `` | `` | `` |
| `` | `` | `` | `` | `` | `` | `` | `` |
| `` | `` | `` | `` | `` | `` | `` | `` |

# 9  影响和注意事项

# 10  部署方案
