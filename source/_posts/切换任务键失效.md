- input命令失效
- EventHub-Input

---

在 Android 系统中，一个按键事件的处理涉及到多个类和层次，从硬件到应用层，按键事件的路径大致如下：

#### 1. **硬件层 (Hardware Layer)**
   - **按键硬件**：当用户按下物理按键（如电源键、音量键、导航键等）或虚拟按键时，硬件层会捕捉到这个事件。
   - **驱动程序 (Driver Layer)**：硬件层的事件通过输入设备驱动程序（如 `keypad.c`）传递到内核层。

#### 2. **内核层 (Kernel Layer)**
   - **Input Subsystem**：内核中的输入子系统处理硬件生成的按键事件。这个子系统包括 `input.c` 等文件，它将按键事件转换为标准的输入事件。
   - **Event Device (`/dev/input/eventX`)**：内核通过输入子系统将事件发送到用户空间，通常通过 `/dev/input/eventX` 设备文件。

#### 3. **Android Native 层 (Android Native Layer)**
   - **EventHub**: 在 Android Native 层，`EventHub` 类负责从 `/dev/input/eventX` 设备文件中读取事件，并将其分发到上层。
   - **InputReader**: `InputReader` 从 `EventHub` 获取原始输入事件，并将其转换为标准的 Android 输入事件，如 `KeyEvent`。
   - **InputDispatcher**: `InputDispatcher` 负责将这些输入事件（如 `KeyEvent`）分发到适当的窗口（如 Activity）中。

#### 4. **Android Framework 层 (Android Framework Layer)**
   - **WindowManagerService (WMS)**: `InputDispatcher` 将按键事件发送到 `WindowManagerService` (WMS)。`WMS` 决定哪个窗口应该接收此事件，然后将事件转发给该窗口。
   - **ViewRootImpl**: 事件传递到应用程序的 `ViewRootImpl`，它是视图树的根。
   - **View**: 最终，按键事件会传递到视图层次结构中的某个 `View`（通常是 `Activity` 的某个 `View`）。`View` 会通过 `dispatchKeyEvent()` 方法接收事件。

#### 5. **应用层 (Application Layer)**
   - **Activity**: 在应用层，`Activity` 类可以通过覆盖 `onKeyDown()`, `onKeyUp()`, 或 `onKeyLongPress()` 方法来处理按键事件。这些方法可以处理用户按键的逻辑，例如响应用户的按键操作。

#### 总结

按键事件的处理路径涉及多个层次和类，具体流程如下：

1. **硬件层**：按键硬件 -> 驱动程序 -> 输入子系统
2. **内核层**：Input Subsystem -> Event Device (`/dev/input/eventX`)
3. **Android Native 层**：`EventHub` -> `InputReader` -> `InputDispatcher`
4. **Framework 层**：`WindowManagerService` -> `ViewRootImpl` -> `View`
5. **应用层**：`Activity` -> `onKeyDown()`, `onKeyUp()`

在应用层开发时，开发者通常只需要处理 `Activity` 中的按键事件，但了解整个事件路径有助于调试和优化事件处理。

---

frameworks/base/data/keyboards/Generic.kl

---



要在 AOSP 10 中的 `EventHub`、`InputReader` 和 `InputDispatcher` 这三个模块中添加日志，以记录按键事件的过程，可以按以下步骤进行。

### 1. **在 `EventHub` 中添加日志**

`EventHub` 负责从设备获取原始输入事件。你可以在处理按键事件的相关函数中添加日志。

```cpp
// 文件位置: frameworks/native/services/inputflinger/EventHub.cpp

#include <android/log.h>
#define LOG_TAG "EventHub"

void EventHub::processEvents(...) {
    // existing code...
    
    if (event.type == EV_KEY) {
        __android_log_print(ANDROID_LOG_INFO, LOG_TAG, "EventHub: Key event code: %d, value: %d", event.code, event.value);
    }
    
    // existing code...
}
```

### 2. **在 `InputReader` 中添加日志**

`InputReader` 负责将 `EventHub` 中的原始事件转换为更高级别的输入事件。

```cpp
// 文件位置: frameworks/native/services/inputflinger/InputReader.cpp

#include <android/log.h>
#define LOG_TAG "InputReader"

void InputReader::processKey(...) {
    // existing code...

    __android_log_print(ANDROID_LOG_INFO, LOG_TAG, "InputReader: Key event code: %d, action: %d", keyEvent.getKeyCode(), keyEvent.getAction());

    // existing code...
}
```

### 3. **在 `InputDispatcher` 中添加日志**

`InputDispatcher` 负责将输入事件分发到正确的目标窗口或应用程序。

```cpp
// 文件位置: frameworks/native/services/inputflinger/InputDispatcher.cpp

#include <android/log.h>
#define LOG_TAG "InputDispatcher"

void InputDispatcher::dispatchKey(...) {
    // existing code...

    __android_log_print(ANDROID_LOG_INFO, LOG_TAG, "InputDispatcher: Dispatching key event code: %d, action: %d", keyEvent.getKeyCode(), keyEvent.getAction());

    // existing code...
}
```

### 4. **编译 AOSP**
在代码中添加了日志后，重新编译你的 AOSP 项目：

```bash
source build/envsetup.sh
lunch <your_device>-userdebug
make -j$(nproc)
```

### 5. **查看日志**
在设备上运行时，可以通过以下命令查看日志：

```bash
adb logcat | grep -e "EventHub" -e "InputReader" -e "InputDispatcher"
```

这将过滤出在 `EventHub`、`InputReader` 和 `InputDispatcher` 中添加的日志，帮助你查看按键事件的详细流程。

### 结论
通过在 `EventHub`、`InputReader` 和 `InputDispatcher` 的关键函数中添加日志，你可以跟踪按键事件的处理流程。在修改代码后，记得重新编译 AOSP 项目，并使用 `adb logcat` 来查看日志输出。

---

rk原始镜像

![image-20240815164846960](https://cdn.jsdelivr.net/gh/chaixiang2002/repo/picgo/img/202408151648865.png)

![image-20240815164929296](https://cdn.jsdelivr.net/gh/chaixiang2002/repo/picgo/img/202408151649497.png)

---

先想办法给所有按键打日志

frameworks/native/services/inputflinger/EventHub.cpp

[Android 输入系统（二）EventHub_android eventhub-CSDN博客](https://blog.csdn.net/VNanyesheshou/article/details/62422404)

[Android 输入系统（二）EventHub - kiydkafa - 博客园 (cnblogs.com)](https://www.cnblogs.com/ydkf85/p/6569258.html)

---

在处理输入事件的上下文中，**注入事件**和**原始事件**是两个不同的概念，它们涉及到输入系统的不同处理阶段和不同的用途。

### 原始事件（Raw Events）

**原始事件**是指直接从输入设备（如键盘、鼠标、触摸屏）读取的事件。这些事件在最底层的输入系统中被生成和捕获。

- **来源**：来自于物理输入设备，通过 `/dev/input` 设备节点（如 `/dev/input/eventX`）。
- **类型**：通常是设备级别的事件，比如按键按下和释放、触摸点移动等。
- **处理流程**：
  1. **EventHub**：原始事件首先由 `EventHub` 组件捕获和处理。`EventHub` 是系统的输入事件捕获层，负责从输入设备读取事件数据。
  2. **InputReader**：`EventHub` 将事件传递给 `InputReader`，`InputReader` 负责解析事件，并将其转发给 `InputDispatcher`。
  3. **InputDispatcher**：`InputDispatcher` 决定如何将事件分发给系统中的不同窗口或应用程序。

原始事件的处理不经过系统应用的直接操作，而是由系统的底层输入管理层直接处理。

### 注入事件（Injected Events）

**注入事件**是指由系统、应用程序或开发者主动创建并插入到输入系统中的事件。这些事件是模拟的，不一定来自于物理输入设备。

- **来源**：由系统内的组件、应用程序或测试脚本通过系统调用（如 `InputManager`）创建和注入。
- **类型**：可以是模拟的按键事件、触摸事件、鼠标事件等。
- **处理流程**：
  1. **InputManager**：事件通过 `InputManager` 被注入到系统中。
  2. **InputDispatcher**：注入的事件会经过 `InputDispatcher`，并按照与原始事件相同的流程进行分发。

注入事件的目的是模拟用户输入，通常用于测试、自动化或在应用中模拟某些用户交互。

### 区别总结

- **来源**：
  - **原始事件**：来自物理输入设备。
  - **注入事件**：由系统或应用程序模拟产生。

- **处理层级**：
  - **原始事件**：由 `EventHub` -> `InputReader` -> `InputDispatcher` 处理。
  - **注入事件**：通过 `InputManager` 注入，并经过 `InputDispatcher` 处理。

- **用途**：
  - **原始事件**：用于处理真实的用户输入。
  - **注入事件**：用于模拟用户输入，常用于测试或自动化脚本中。

### 日志记录

- **原始事件**：可以在 `EventHub` 或 `InputReader` 处添加日志来记录原始事件。
- **注入事件**：可以在 `InputManager::injectKeyEvent()` 或 `injectInputAfterTransactionsApplied()` 方法中添加日志来记录注入事件。

### 代码示例

如果你希望在原始事件和注入事件中添加日志，你可以在以下位置进行操作：

- **原始事件日志**：
  - `EventHub` 的事件处理代码。
  - `InputReader` 的事件解析代码。

- **注入事件日志**：
  - `InputManager::injectKeyEvent()` 方法。
  - `injectInputAfterTransactionsApplied()` 方法。

在这些函数中，你可以使用 `Log.d(TAG, "Your message")` 或其他 `Log` 方法来记录事件的信息，以便在 `logcat` 中查看。

![img](https://cdn.jsdelivr.net/gh/chaixiang2002/repo/picgo/img/202408162249733.png)

[Android Framework 输入子系统（07）APP建立联系_inputdispatcher windowstate-CSDN博客](https://blog.csdn.net/vviccc/article/details/93061885)









 MSG_DISPATCH_SHOW_RECENTS = 9;

**frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java**

public void showRecentApps() {

​		mPolicy.showRecentApps();

**frameworks/base/services/core/java/com/android/server/policy/WindowManagerPolicy.java**

interface WindowManagerPolicy

​		public void showRecentApps();

**frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java**

public void showRecentApps()

​		mHandler.obtainMessage(MSG_DISPATCH_SHOW_RECENTS).sendToTarget();

case MSG_DISPATCH_SHOW_RECENTS:*showRecentApps(false)*;

private void showRecentApps(boolean triggeredFromAltTab) 









---

**frameworks/base/services/core/java/com/android/server/wm/InputManagerCallback.java**

public long interceptKeyBeforeDispatching(  IBinder focus, KeyEvent event, int policyFlags) 

mService.mPolicy.interceptKeyBeforeDispatching(windowState, event, policyFlags)

**frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java**
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) 

​		result = interceptKeyBeforeDispatchingInner(win, event, policyFlags);

private long interceptKeyBeforeDispatchingInner(WindowState win, KeyEvent event, int policyFlags)

​		keyCode == KeyEvent.KEYCODE_APP_SWITCH
​		preloadRecentApps();

​		private void preloadRecentApps()

​		statusbar = getStatusBarManagerInternal();

​		*statusbar.preloadRecentApps*();

StatusBarManagerInternal getStatusBarManagerInternal()

mStatusBarManagerInternal =LocalServices.getService(StatusBarManagerInternal.class);

**frameworks/base/core/java/com/android/server/LocalServices.java**

public static <T> T getService(Class<T> type)

**frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/CommandQueue.java**

handleMessage(Message msg)
		case MSG_PRELOAD_RECENT_APPS:
		mCallbacks.get(i).preloadRecentApps();
**frameworks/base/packages/SystemUI/src/com/android/systemui/recents/Recents.java**

public void preloadRecentApps()
		mImpl.preloadRecentApps();

**frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java**

public void preloadRecentApps()

**frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/notification/InstantAppNotifier.java**

public void preloadRecentApps()

​		updateForegroundInstantApps();

private void updateForegroundInstantApps()





```shell
am start -n com.android.launcher3/com.android.quickstep.RecentsActivity
```

10.2.0.39

ZP010004000183

```
sendevent /dev/input/event6 1 139 1
sendevent /dev/input/event6 0 0 0
sendevent /dev/input/event6 1 139 0
sendevent /dev/input/event6 0 0 0



```

