这段代码实现了一个简单的基于事件驱动的 TCP 服务器，使用了多线程和异步 I/O 操作。服务器主要是通过事件循环来处理不同事件（如读取请求、写入响应等），在接收到 HTTP 请求后处理内容并响应。

### 主要模块和结构

1. **`lazy_static!`**：用于定义在全局范围内只有一次初始化的静态变量。
   - `EXECUTOR`：一个 `Mutex<executor::Executor>` 类型的静态变量，用来控制并发执行任务。
   - `REACTOR`：一个 `Mutex<reactor::Reactor>` 类型的静态变量，用来管理事件循环和 I/O 多路复用。
   - `CONTEXTS`：一个 `Mutex<HashMap<EventId, RequestContext>>` 类型的静态变量，用来存储与每个事件相关的请求上下文信息。

2. **`RequestContext`**：表示每个连接的上下文，存储了 TCP 流、请求的内容长度以及读取的数据缓冲区。

### 主要函数

#### `main()`
`main` 函数是程序的入口点。它执行以下操作：
- 创建一个 TCP 监听器，绑定到 `127.0.0.1:8000`。
- 设置监听器为非阻塞模式。
- 获取事件 ID，准备通过 `REACTOR` 来处理事件循环。
- 注册监听器的可读事件，这样当有新连接时会触发事件。
- 启动 `REACTOR` 以运行事件循环并监听事件。
- 循环等待并处理事件，调用 `EXECUTOR` 执行事件。

#### `listener_cb()`
这个回调函数用于处理新接受到的 TCP 连接：
- 它会在监听器的 `accept` 被触发时调用。
- 为每个新的连接生成一个 `event_id`，并将其设置为非阻塞。
- 将该连接的请求上下文 (`RequestContext`) 存入 `CONTEXTS` 中。
- 注册这个连接的可读事件，使得当有数据可读时，能够继续读取数据。
- 调用 `read_cb` 函数开始读取数据。

#### `read_cb()`
这是读取数据的回调函数：
- 它会在 TCP 连接的数据可读取时触发。
- 在这个函数中，通过调用 `self.stream.read()` 来读取数据到缓冲区。
- 解析 HTTP 请求头并提取 `Content-Length`，如果数据读取完整，则触发写事件。如果数据未读取完整，继续等待读取事件。
- 最后，注册对应的读事件或者写事件。

#### `write_cb()`
这是写数据的回调函数：
- 当数据读取完成后，会触发写回调。
- 它会将预定义的 HTTP 响应 (`HTTP_RESP`) 写入连接的 TCP 流。
- 写入完成后，关闭连接。
- 清理已处理的连接，关闭相关的文件描述符并从 `CONTEXTS` 中移除该事件的上下文。

#### `RequestContext::new()`
`RequestContext::new()` 是 `RequestContext` 结构体的构造函数：
- 它初始化了一个新的 `RequestContext`，将传入的 `TcpStream` 和一些默认值（如空的缓冲区、内容长度为0）作为初始化数据。

#### `RequestContext::read_cb()`
`read_cb` 函数用于读取数据并解析 HTTP 请求头：
- 它在每次读取数据时都会检查请求头是否包含 `Content-Length` 字段，并提取其值。
- 如果数据已经读取完整，会触发写操作并注册写事件；如果数据未完全接收，则注册继续读操作。

#### `RequestContext::write_cb()`
`write_cb` 函数会将 HTTP 响应数据写入客户端：
- 它首先构造一个固定的 HTTP 响应，写入到 `TcpStream` 中。
- 写入完成后，调用 `shutdown` 方法关闭连接。
- 最后，通过 `REACTOR` 关闭相关的文件描述符并从 `CONTEXTS` 中移除该事件的上下文。

#### `read_cb()` 和 `write_cb()`（外部函数）
这些是外部封装的回调函数，简化了从上下文中获取事件并执行读写操作的过程：
- `read_cb()` 会调用 `RequestContext::read_cb()`。
- `write_cb()` 会调用 `RequestContext::write_cb()`。

### 核心概念

- **事件循环**：代码的核心是事件循环，使用 `REACTOR` 来监听和分发 I/O 事件。`read_interest` 和 `write_interest` 是注册不同 I/O 事件的方法，允许根据事件的发生触发相应的回调。
- **非阻塞 I/O**：所有的 I/O 操作（如读取和写入 TCP 流）都是非阻塞的，即不会阻塞主线程等待 I/O 操作完成，而是通过事件循环机制在合适的时候处理它们。
- **上下文管理**：每个 TCP 连接都有一个 `RequestContext` 用来存储与该连接相关的状态信息（如缓冲区、请求头等）。通过 `CONTEXTS` 全局哈希表来管理每个事件的上下文，确保在事件回调时能够访问到正确的连接数据。

### 总结

这段代码实现了一个基于事件驱动的网络服务器，结合了异步 I/O 和多线程处理，能够高效地处理并发连接。通过使用 `Reactor` 和 `Executor` 模式，代码可以在不阻塞主线程的情况下响应多客户端请求。